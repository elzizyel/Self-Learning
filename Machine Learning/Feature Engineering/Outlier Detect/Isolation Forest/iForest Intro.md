## 1. Intro

​	iForest 是一种基于Ensemble的异常检测方法，它适用于continuous vars的异常检测，将异常定义为容易被孤立的离群点—可以理解为分布稀疏且离密度高的群体较远的点。从统计学角度来看，就是分布稀疏的区域即表示数据发生在此区域的概率很低，因此可以认为落在这里的数据点是异常的。

​	



## 2. Method Intro

​	假设我们现在有一个数据集，里面全部都是continuous vars，然后随机使用一个超平面去切割这个数据空间。然后不停循环切下去，直到所有数据空间里都只有一个数据点。那么从直观上来讲，密度很高的簇要被切很多次才会每一个数据点有自己的空间，而密度很低的点很早就停留到一个子空间里去了。

最简单的具体流程如下:

1. 从数据中随机选择N个样本点作为subsample，将其放入一个iTree的根节点
2. 随机指定一个feature，然后根据当前节点数据中随机产生一个切割点p; 且切割点产生于当前节点数据中指定维度的最大值和最小值之间
3. 以此切割点我们有了一个超平面，将当前节点的数据空间划分为2个子空间，产生两个子节点
4. 在子节点中重复步骤2和3，不断构造新的子节点，直到子节点中只有一个数据点(无法再切割)，或者子节点已经达到限定的高度。
5. 每一次执行1-4会产生一个iTree，产生t个iTree之后，iForest的训练就结束了。之后就可以用这个iForest来评估数据了。
6. 对于一个测试数据集x， 会让其遍历每一颗iTree，然后计算x里面的每个数据点落在了每个iTree的第几层，然后我们就可以得出每个数据点的高度平均值。
7. 在得到每个数据点的高度平均值之后，可以设置一个阈值，当高度值低于此阈值即为异常 | 在论文里对树的高度进行了归一化，输出一个0-1的值，值越接近于1则异常的可能性越高。



## 3. Summary

1. iForest具有线性时间复杂度，是因为ensemble的方法，即O(n)的复杂度。通常树的数量越多，算法越稳定，每棵树是相互独立生成的，因此可以部署在大规模分布式系统上
2. iForest不适合特别高维的数据(Feature特别多)，由于每次切数据空间都是随机选取一个维度进行切割的，可能一棵树建完，里面还有一些feature没有被分割过，即大量信息没有被使用过。对于这类feature特别多的dataset，我们可以使用Subspace Anomaly Detection即子空间异常检测。
3. iForest仅对Global Anomaly敏感，即全局稀疏点敏感，不擅长处理局部稀疏点(Local Anomaly)； 相对的如果要检测局部的异常值可以使用LOF或者发表于PAKDD用来改进iForest的方法。"Improving iForest with Relative Mass"
4. 当训练样本中异常样本的比例比较高的时候，最终的结果可能会受到影响
5. 在特征选择的时候最好过滤不太相关的特征，或者在预处理的时候把不不关注的特征normalized